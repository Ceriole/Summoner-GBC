import argparse
import json
import os
import re

animname_regex = r'(\w+)-([\w_]+)-(\d+)\.ase'

args : argparse.Namespace;

def main() -> None:
    global args
    args = parse_args()
    data = parse_json(json.load(args.inputfile))
    outdir = os.path.dirname(args.output)
    outfilepath = os.path.splitext(args.output)[0]
    targext = os.path.splitext(args.output)[1].lower()
    basefile = os.path.basename(outfilepath)
    sourcetype = targext
    if args.force_type != None:
        sourcetype = args.force_type
    typeslist = ['c', 'h']
    typeslist.remove(sourcetype)
    othertype = typeslist[0]
    descriptor = basefile
    if args.name != None:
        descriptor = args.name
    bank = None
    if args.bank != None:
        if args.bank in range(0,256):
            bank = args.bank
        else:
            raise ValueError('Bank must be within 0 and 255! Bank: ' + str(args.bank))
    if args.verbose:
        print(args.inputfile.name, 'to C data:', descriptor, end='')
        if bank != None:
            print(' (Bank: ' + str(args.bank) + ')')
        print('Generating', sourcetype, 'file to', args.output)
        if args.module:
            print('Generating', othertype, 'file to', outfilepath + '.' + othertype)
    data['meta']['bank'] = bank
    data['meta']['descriptor'] = descriptor
    data['meta']['type'] = sourcetype
    data['meta']['filename'] = basefile + '.' + data['meta']['type']
    source = gen_source(data)
    with open(outdir + '/' + data['meta']['filename'], 'w') as file:
        file.write(source)
    if args.module:
        data['meta']['type'] = othertype
        data['meta']['filename'] = basefile + '.' + data['meta']['type']
        source = gen_source(data)
        with open(outdir + '/' + data['meta']['filename'], 'w') as file:
            file.write(source)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description='Converts Aseprite JSON files into C headers and gameboy-compatible byte data.',
        epilog='Written by Ceriole in 2022 for SUMMONER.'
    )
    parser.add_argument('inputfile', type=open, help='Input Aseprite generated JSON')
    parser.add_argument('-o', '--output', type=str, help='Output .c or .h file.', required=True)
    parser.add_argument('-f', '--fps', type=float, default=59.77, help='Used to convert millisecond delays to frame delays. (GB runs at ~59.77 fps)')
    parser.add_argument('-n', '--name', type=str, help='Name of the C descriptor to generate.')
    parser.add_argument('--force-type', type=str, choices=['c', 'h'], default='c', help='Force the type of C source file to generate.')
    parser.add_argument('-v', '--verbose', action='store_true', help='Print extra information.')
    parser.add_argument('-m', '--module', action='store_true', help='Create both .c and .h files.')
    parser.add_argument('-b', '--bank', type=int, help='Set the source file\'s bank for GBDK. [0..255]')
    return parser.parse_args()

def parse_json(json_data: dict) -> dict[str, dict]:
    data = {}
    data['meta'] = json_data['meta']
    frame_durations = []
    for frame_data in json_data['frames']:
        frame_durations.append(frame_data['duration'])
    data['frame_durations'] = frame_durations
    data['tags'] = parse_tag_data(json_data)
    return data

def parse_tag_data(data: dict) -> dict[str, dict]:
    tags = {}
    for tag_data in data['meta']['frameTags']:
        tags[tag_data['name']] = { 'frames': [*range(int(tag_data['from']), int(tag_data['to']) + 1)], 'direction':tag_data['direction'] }
    return tags

def gen_source(data: dict) -> str:
    if data['meta']['type'] == 'c':
        return gen_c_source(data)
    elif data['meta']['type'] == 'h':
        return gen_h_source(data)
    else:
        raise ValueError('Unknown source type: ' + data['type'])

def gen_header(data: dict) -> str:
    output = '/*\n* %s auto-generated by %s\n'%(data['meta']['filename'], os.path.split(__file__)[1])
    output += '* Frame count: %d\n'%(len(data['frame_durations'])) 
    output += '* Tag count: %d\n'%(len(data['tags']))
    output += '* Tags: %s\n'%(str(data['tags'].keys()))
    output += '* Bank: %d\n'%(int(data['meta']['bank']))
    output += '*/\n\n'
    return output

def gen_c_source(data: dict) -> str:
    output = gen_header(data)
    descriptor = data['meta']['descriptor'];

    output += '#include "%s"\n\n'%(data['meta']['filename'].replace('.c', '.h'))
    output += '#include <gbdk/platform.h>\n'
    output += '#include "gfx/object.h"\n\n'

    output += '#pragma bank %d\n\n'%(int(data['meta']['bank']))
    output += 'BANKREF(%s)\n\n'%(descriptor)

    anim_descriptors = []
    for tag_name, tag_data in data['tags'].items():
        frames = tag_data['frames']
        anim_descriptor = '%s_%s'%(descriptor, tag_name.lower())
        anim_descriptors.append('\t&' + anim_descriptor)
        output += 'const animation_t %s = { %d, {'%(anim_descriptor, len(frames))
        frames_str_list = []
        for frame in frames:
            frame_duration = max(round(data['frame_durations'][frame] * (args.fps / 1000.0)), 1)
            frames_str_list.append('{%d, %d}'%(frame, frame_duration))
        output += ', '.join(frames_str_list)
        output += '} };\n'
    output += '\nconst animation_t* const %s[%s_COUNT] = {\n'%(descriptor, descriptor.upper())
    output += ',\n'.join(anim_descriptors)
    output += '\n};\n\n'

    return output

def gen_h_source(data: dict) -> str:
    output = gen_header(data)
    headerfiledef = '__' + data['meta']['filename'].upper().replace('.', '_') + '__'
    output += '#ifndef %s\n'%(headerfiledef)
    output += '#define %s\n\n'%(headerfiledef)

    output += '#include <gbdk/platform.h>\n'
    output += '#include "gfx/object.h"\n\n'

    descriptor = data['meta']['descriptor'];
    output += 'BANKREF_EXTERN(%s)\n\n'%(descriptor)

    tag_idx = 0
    output += '#define %s_COUNT %d\n'%(descriptor.upper(), len(data['tags']))
    for tag_name in data['tags'].keys():
        output += '#define %s_%s_INDEX %d\n'%(descriptor.upper(), tag_name.upper(), tag_idx)
        tag_idx += 1
    output += '\n'

    anim_descriptors = []
    for tag_name, tag_data in data['tags'].items():
        frames = tag_data['frames']
        anim_descriptor = '%s_%s'%(descriptor, tag_name.lower())
        anim_descriptors.append('\t&' + anim_descriptor)
        output += 'extern const animation_t %s;\n'%anim_descriptor
    output += '\nextern const animation_t* const %s[%s_COUNT];\n\n'%(descriptor, descriptor.upper())
    output += '#endif // %s\n'%(headerfiledef)
    return output

if __name__ == '__main__':
    main()
import argparse
import json
import os
import re

animname_regex = r'(\w+)-([\w_]+)-(\d+)\.ase'

args : argparse.Namespace = None;

def main() -> None:
    global args
    args = parse_args()
    data = parse_json(json.load(args.inputfile))
    outdir = os.path.dirname(args.output)
    outfilepath = os.path.splitext(args.output)[0]
    targext = os.path.splitext(args.output)[1].lower()
    basefile = os.path.basename(outfilepath)
    sourcetype = targext
    if args.force_type != None:
        sourcetype = args.force_type
    typeslist = ['c', 'h']
    typeslist.remove(sourcetype)
    othertype = typeslist[0]
    descriptor = basefile
    if args.name != None:
        descriptor = args.name
    bank = None
    if args.bank != None:
        if args.bank in range(0,256):
            bank = args.bank
        else:
            raise ValueError('Bank must be within 0 and 255! Bank: ' + str(args.bank))
    if args.verbose:
        print(args.inputfile.name, 'to C data:', descriptor, end='')
        if bank != None:
            print(' (Bank: ' + str(args.bank) + ')')
        print('Generating', sourcetype, 'file to', args.output)
        if args.module:
            print('Generating', othertype, 'file to', outfilepath + '.' + othertype)
    data['meta']['bank'] = bank
    data['meta']['descriptor'] = descriptor
    data['meta']['type'] = sourcetype
    data['meta']['filename'] = basefile + '.' + data['meta']['type']
    source = gen_source(data)
    with open(outdir + '/' + data['meta']['filename'], 'w') as file:
        file.write(source)
    if args.module:
        data['meta']['type'] = othertype
        data['meta']['filename'] = basefile + '.' + data['meta']['type']
        source = gen_source(data)
        with open(outdir + '/' + data['meta']['filename'], 'w') as file:
            file.write(source)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description='Converts Aseprite JSON files into C headers and gameboy-compatible byte data.',
        epilog='Written by Ceriole in 2022 for SUMMONER.'
    )
    parser.add_argument('inputfile', type=open, help='Input Aseprite generated JSON')
    parser.add_argument('-o', '--output', type=str, help='Output .c or .h file.', required=True)
    parser.add_argument('-f', '--fps', type=float, default=59.77, help='Used to convert millisecond delays to frame delays. (GB runs at ~59.77 fps)')
    parser.add_argument('-n', '--name', type=str, help='Name of the C descriptor to generate.')
    parser.add_argument('--force-type', type=str, choices=['c', 'h'], default='c', help='Force the type of C source file to generate.')
    parser.add_argument('-v', '--verbose', action='store_true', help='Print extra information.')
    parser.add_argument('-m', '--module', action='store_true', help='Create both .c and .h files.')
    parser.add_argument('-b', '--bank', type=int, help='Set the source file\'s bank for GBDK. [0..255]')
    return parser.parse_args()

def parse_json(json_data: dict) -> dict[str, dict]:
    data = {}
    data['meta'] = json_data['meta']
    frames = []
    for frame_data in json_data['frames']:
        frames.append(parse_frame(frame_data))
    data['frames'] = frames
    return data

def parse_frame(frame_data: dict) -> dict[str, int]:
    frame = {}
    frame['x'] = frame_data['frame']['x']
    frame['y'] = frame_data['frame']['y']
    frame['w'] = frame_data['frame']['w']
    frame['h'] = frame_data['frame']['h']
    frame['duration'] = frame_data['duration']
    fn_match = re.search(animname_regex, frame_data['filename'])
    frame['tag'] = fn_match.group(2).lower()
    frame['frame_idx'] = int(fn_match.group(3))
    return frame

def get_tag_list(data: dict) -> list[str]:
    tags = []
    for frame in data['frames']:
        if frame['tag'] not in tags:
            tags.append(frame['tag'])
    return tags

def get_tag_frames(data: dict, tag: str) -> list[dict]:
    frames = []
    for frame in data['frames']:
        if frame['tag'] == tag.lower():
            frames.append(frame)
    return frames

def gen_source(data: dict) -> str:
    if data['meta']['type'] == 'c':
        return gen_c_source(data)
    elif data['meta']['type'] == 'h':
        return gen_h_source(data)
    else:
        raise ValueError('Unknown source type: ' + data['type'])

def gen_header(data: dict) -> str:
    output = '/*\n* %s auto-generated by %s\n'%(data['meta']['filename'], os.path.split(__file__)[1])
    output += '* Frame count: %d\n'%(len(data['frames'])) 
    output += '* Tag count: %d\n'%(len(get_tag_list(data)))
    output += '* Tags: %s\n'%(str(get_tag_list(data)))
    output += '* Bank: %d\n'%(int(data['meta']['bank']))
    output += '*/\n\n'
    return output

def gen_c_source(data: dict) -> str:
    output = gen_header(data)
    
    output += '#include <gbdk/platform.h>\n\n'
    output += '#include "gfx/object.h"\n\n'

    descriptor = data['meta']['descriptor'];
    output += '#pragma bank %d\n\n'%(int(data['meta']['bank']))
    output += 'BANKREF(%s)\n\n'%(descriptor)
    tags = get_tag_list(data)
    frame_descriptors = []
    for tag in tags:
        frames = get_tag_frames(data, tag)
        frame_descriptor = '%s_%s'%(descriptor, tag)
        frame_descriptors.append('\t&' + frame_descriptor)
        output += 'const animation_t %s = { %d, {'%(frame_descriptor, len(frames))
        frames_str_list = []
        for frame in frames:
            ms_idx = frame['x'] // frame['w']
            frame_duration = max(round(frame['duration'] * (args.fps / 1000.0)), 1)
            frames_str_list.append('{%d, %d}'%(ms_idx, frame_duration))
        output += ', '.join(frames_str_list)
        output += '} };\n'
    output += '\nconst animation_t* const %s[%d] = {\n'%(descriptor, len(tags))
    output += ',\n'.join(frame_descriptors)
    output += '\n};\n\n'

    return output

def gen_h_source(data: dict) -> str:
    output = gen_header(data)
    headerfiledef = '__' + data['meta']['filename'].upper().replace('.', '_') + '__'
    output += '#ifndef %s\n'%(headerfiledef)
    output += '#define %s\n\n'%(headerfiledef)

    output += '#include <gbdk/platform.h>\n\n'
    output += '#include "gfx/object.h"\n\n'

    descriptor = data['meta']['descriptor'];
    output += 'BANKREF_EXTERN(%s)\n\n'%(descriptor)
    tags = get_tag_list(data)
    frame_descriptors = []
    for tag in tags:
        frames = get_tag_frames(data, tag)
        frame_descriptor = '%s_%s'%(descriptor, tag)
        frame_descriptors.append('\t&' + frame_descriptor)
        output += 'extern const animation_t %s;\n'%(frame_descriptor)
    output += '\nextern const animation_t* const %s[%d];\n\n'%(descriptor, len(tags))
    output += '#endif // %s\n'%(headerfiledef)
    return output

if __name__ == '__main__':
    main()